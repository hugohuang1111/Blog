import{_ as i}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,d as n,o as e}from"./app-CQ2TP62M.js";const l="/Blog/assets/202108/outline1.jpg",t="/Blog/assets/202108/outline2.jpg",h={};function p(r,s){return e(),a("div",null,s[0]||(s[0]=[n('<h2 id="简介" tabindex="-1"><a class="header-anchor" href="#简介"><span>简介</span></a></h2><p>本文介绍如何在一个模型上实现内/外发光</p><h2 id="效果与思路" tabindex="-1"><a class="header-anchor" href="#效果与思路"><span>效果与思路</span></a></h2><p>外发光:<br> 将模型按法线向外扩展一定的距离, 然后将法线与视角做点积, 这个点积就是一个从中间往外渐变弱的效果, 最后再将模型渲染出来, 就可以行到一个外发光的效果, 如图.</p><figure><img src="'+l+'" alt="外发光" tabindex="0" loading="lazy"><figcaption>外发光</figcaption></figure><p>内发光:<br> 原理同外发光很像, 不过不会向外扩展, 同时再将法线与视解的点积用1去减, 取差值, 就是一个从外向内渐变弱的效果, 这里就是先渲染模型, 再渲染内发光的渐变了. 同样如上图.</p><figure><img src="'+t+`" alt="内发光" tabindex="0" loading="lazy"><figcaption>内发光</figcaption></figure><h2 id="外发光实现" tabindex="-1"><a class="header-anchor" href="#外发光实现"><span>外发光实现</span></a></h2><p>顶点里主要操作就是往外扩:</p><div class="language-shader line-numbers-mode" data-highlighter="shiki" data-ext="shader" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-shader"><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">vec4 vert () {</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    StandardVertInput In;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    CCVertInput(In);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    scNormal = In.</span><span style="--shiki-light:#986801;--shiki-dark:#ABB2BF;">normal</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    vec4 pos = In.position;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    pos.w = </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // 外扩 outlineParams.z</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    pos.xyz += In.</span><span style="--shiki-light:#986801;--shiki-dark:#ABB2BF;">normal</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> * outlineParams.z;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    mat4 matWorld, matWorldIT;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    CCGetWorldMatrixFull(matWorld, matWorldIT);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    scWorldPos = matWorld * pos;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    scNormal = normalize((matWorldIT * vec4(scNormal, </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">0.0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)).xyz);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    pos = cc_matProj * (cc_matView * matWorld) * pos;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    return pos;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>片元里主要操作就是视线与法线点积, 再作幂操作</p><div class="language-shader line-numbers-mode" data-highlighter="shiki" data-ext="shader" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-shader"><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">vec4 frag () {</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    vec4 </span><span style="--shiki-light:#0184BC;--shiki-dark:#ABB2BF;">color</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> = rimColor;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    vec3 V = normalize(cc_cameraPos.xyz - scWorldPos.xyz);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    vec3 N = normalize(scNormal);</span></span>
<span class="line"><span style="--shiki-light:#0184BC;--shiki-dark:#ABB2BF;">    float</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> dotVal = dot(V, N);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    dotVal = saturate(dotVal);</span></span>
<span class="line"><span style="--shiki-light:#0184BC;--shiki-dark:#ABB2BF;">    color</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#986801;--shiki-dark:#ABB2BF;">a</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> = pow(dotVal, outlineParams.x);</span></span>
<span class="line"><span style="--shiki-light:#0184BC;--shiki-dark:#ABB2BF;">		color</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#986801;--shiki-dark:#ABB2BF;">a</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> *=  outlineParams.y * dotVal;</span></span>
<span class="line"><span style="--shiki-light:#0184BC;--shiki-dark:#ABB2BF;">    color</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#986801;--shiki-dark:#ABB2BF;">a</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> = clamp(</span><span style="--shiki-light:#0184BC;--shiki-dark:#ABB2BF;">color</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#986801;--shiki-dark:#ABB2BF;">a</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">., </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">0.8</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    return CCFragOutput(</span><span style="--shiki-light:#0184BC;--shiki-dark:#ABB2BF;">color</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="内发光实现" tabindex="-1"><a class="header-anchor" href="#内发光实现"><span>内发光实现</span></a></h2><p>顶点里就是基本操作:</p><div class="language-shader line-numbers-mode" data-highlighter="shiki" data-ext="shader" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-shader"><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">vec4 vert () {</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    ...</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    pos = cc_matProj * (cc_matView * matWorld) * pos;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    return pos;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>片元里主要操作同外发光, 最后加再去 1 去减 a 的值</p><div class="language-shader line-numbers-mode" data-highlighter="shiki" data-ext="shader" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-shader"><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  vec4 frag () {</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    ...</span></span>
<span class="line"><span style="--shiki-light:#0184BC;--shiki-dark:#ABB2BF;">    color</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#986801;--shiki-dark:#ABB2BF;">a</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> = </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">. - </span><span style="--shiki-light:#0184BC;--shiki-dark:#ABB2BF;">color</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#986801;--shiki-dark:#ABB2BF;">a</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    return CCFragOutput(</span><span style="--shiki-light:#0184BC;--shiki-dark:#ABB2BF;">color</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="详细实现" tabindex="-1"><a class="header-anchor" href="#详细实现"><span>详细实现</span></a></h2><p><a href="https://github.com/hugohuang1111/fxcase" target="_blank" rel="noopener noreferrer">https://github.com/hugohuang1111/fxcase</a></p><hr><p>转自: <a href="http://www.hugohuang.xyz/" target="_blank" rel="noopener noreferrer">HH</a></p>`,21)]))}const c=i(h,[["render",p]]),o=JSON.parse('{"path":"/posts/2021-08-09-outline-effect.html","title":"内发光, 外发光特效","lang":"zh-CN","frontmatter":{"title":"内发光, 外发光特效","date":"2021-08-09T00:00:00.000Z","author":"hugo","tag":["effect"],"description":"简介 本文介绍如何在一个模型上实现内/外发光 效果与思路 外发光: 将模型按法线向外扩展一定的距离, 然后将法线与视角做点积, 这个点积就是一个从中间往外渐变弱的效果, 最后再将模型渲染出来, 就可以行到一个外发光的效果, 如图. 外发光外发光 内发光: 原理同外发光很像, 不过不会向外扩展, 同时再将法线与视解的点积用1去减, 取差值, 就是一个从外...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"内发光, 外发光特效\\",\\"image\\":[\\"https://mister-hope.github.io/Blog/assets/202108/outline1.jpg\\",\\"https://mister-hope.github.io/Blog/assets/202108/outline2.jpg\\"],\\"datePublished\\":\\"2021-08-09T00:00:00.000Z\\",\\"dateModified\\":\\"2025-06-21T17:07:42.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"hugo\\"}]}"],["meta",{"property":"og:url","content":"https://mister-hope.github.io/Blog/posts/2021-08-09-outline-effect.html"}],["meta",{"property":"og:site_name","content":"HH"}],["meta",{"property":"og:title","content":"内发光, 外发光特效"}],["meta",{"property":"og:description","content":"简介 本文介绍如何在一个模型上实现内/外发光 效果与思路 外发光: 将模型按法线向外扩展一定的距离, 然后将法线与视角做点积, 这个点积就是一个从中间往外渐变弱的效果, 最后再将模型渲染出来, 就可以行到一个外发光的效果, 如图. 外发光外发光 内发光: 原理同外发光很像, 不过不会向外扩展, 同时再将法线与视解的点积用1去减, 取差值, 就是一个从外..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://mister-hope.github.io/Blog/assets/202108/outline1.jpg"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-06-21T17:07:42.000Z"}],["meta",{"property":"article:author","content":"hugo"}],["meta",{"property":"article:tag","content":"effect"}],["meta",{"property":"article:published_time","content":"2021-08-09T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-06-21T17:07:42.000Z"}]]},"git":{"createdTime":1750525662000,"updatedTime":1750525662000,"contributors":[{"name":"hugo","username":"hugo","email":"hugohuang1111@gmail.com","commits":1,"url":"https://github.com/hugo"}]},"readingTime":{"minutes":1.3,"words":391},"filePathRelative":"posts/2021-08-09-outline-effect.md","excerpt":"<h2>简介</h2>\\n<p>本文介绍如何在一个模型上实现内/外发光</p>\\n<h2>效果与思路</h2>\\n<p>外发光:<br>\\n将模型按法线向外扩展一定的距离, 然后将法线与视角做点积, 这个点积就是一个从中间往外渐变弱的效果, 最后再将模型渲染出来, 就可以行到一个外发光的效果, 如图.</p>\\n<figure><img src=\\"/assets/202108/outline1.jpg\\" alt=\\"外发光\\" tabindex=\\"0\\" loading=\\"lazy\\"><figcaption>外发光</figcaption></figure>\\n<p>内发光:<br>\\n原理同外发光很像, 不过不会向外扩展, 同时再将法线与视解的点积用1去减, 取差值, 就是一个从外向内渐变弱的效果, 这里就是先渲染模型, 再渲染内发光的渐变了. 同样如上图.</p>","autoDesc":true}');export{c as comp,o as data};
