import{_ as n}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,d as e,o as i}from"./app-CQ2TP62M.js";const p={};function l(r,s){return i(),a("div",null,s[0]||(s[0]=[e(`<h2 id="前言" tabindex="-1"><a class="header-anchor" href="#前言"><span>前言</span></a></h2><p>早上刷新闻时看到了排序算法, 今天就来说说我所知道用到的一些排序算法.</p><h2 id="排序算法" tabindex="-1"><a class="header-anchor" href="#排序算法"><span>排序算法</span></a></h2><h3 id="冒泡" tabindex="-1"><a class="header-anchor" href="#冒泡"><span>冒泡</span></a></h3><p>最经典的排序算法了, 它最思想就是相邻的两个数对比, 并保证, 他们的顺序是按目标顺序排列的.</p><p>例子, 我们要从小到大. 过程如下:</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-"><span class="line"><span>1 4 5 3 2  // 原始队列</span></span>
<span class="line"><span>1 4 5 3 2  // 1 与 4 不同交换</span></span>
<span class="line"><span>1 4 5 3 2  // 4 与 5 也不同交换</span></span>
<span class="line"><span>1 4 3 5 2  // 5 与 3 需要交换</span></span>
<span class="line"><span>1 4 3 2 5  // 5 与 2 需要交换</span></span>
<span class="line"><span>// 到这里一轮结束, 同时可以注意到最时最大的 5 已经到最后的位置了, 下一轮在前 4 个数中再重复上面的步骤即可</span></span>
<span class="line"><span></span></span>
<span class="line"><span>....</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>说明: 冒泡一直在做的事就是让相邻的两个数满足目标的大小关系(左大于右, 还是右大于左).<br> 其实在每一轮的过程中, 就会有一个数找到它的位置.<br> 在数据的比较中, 要注意一个地方就是数据流动的方向, 如果是按最大的向右流动, 那么一轮之后, 这一轮最右的那个位置就不在下一轮的范围内了.<br> 同理, 如果是最大的向左流动, 那么这一轮最左的位置, 就不在下一轮的范围内了.</p><h3 id="插入排序" tabindex="-1"><a class="header-anchor" href="#插入排序"><span>插入排序</span></a></h3><p>插入排序的基本思想是, 先预想第一个数, 已经排好了, 然后把第二个数插入到第一个数的队列中. 同理再把第三个数插入到前面两个数组成的队列中, 依次类推.</p><p>例子, 我们要从小到大. 过程如下:</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-"><span class="line"><span>1 4 5 3 2  // 原始队列</span></span>
<span class="line"><span>1 4 5 3 2  // 1 自己是一个队列</span></span>
<span class="line"><span>1 4 5 3 2  // 把 4 加入到 1 中, 4 与 1 比较, 满足, 不用动</span></span>
<span class="line"><span>1 4 5 3 2  // 把 5 与 1, 4 比较, 满足, 不用动</span></span>
<span class="line"><span>1 3 4 5 2  // 把 3 与 1, 4, 5 比较, 3 应该在 4 前面, 插入</span></span>
<span class="line"><span>1 2 3 4 5  // 把 2 与 1, 3, 4, 5 比较, 2 应该在 3 前面, 插入</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="快速排序" tabindex="-1"><a class="header-anchor" href="#快速排序"><span>快速排序</span></a></h3><p>快速排序是我们接触得比较多的一种算法了, 总的思想就是先随机找一个数, 再以这个数为标, 把原来的数就可以分成两部分(大于标的数与不大于标的数), 然后再对这分出来的这两部分再做随机在其中选一个数, 再往下分, 如此下去, 当不可再分时, 排序也就完成了.</p><p>快速排序, 最主要的思想就是分而治之<br> 快速排序, 会快, 其实最主要还是分而治之了, 这样小的那部分数就不用再和大的那部分数去比较, 好的情况下就少了一半的比较量. 当然差的情况下(每一次其中一部分的数量都是0, 这时的 标的数 就是最小,最大的时候), 其实和冒泡/插入也一样了, 基本就要和所有的数依次比较.</p><p>例子, 我们要从小到大. 过程如下:</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-"><span class="line"><span>1 4 5 3 2  // 以 1 为标的数, 把 1 与最右侧的 2 比较, 满足, 不动</span></span>
<span class="line"><span>1 4 5 3 2  // 把 1 与最右侧的 3 比较, 满足, 不动</span></span>
<span class="line"><span>1 4 5 3 2  // 把 1 与最右侧的 5 比较, 满足, 不动</span></span>
<span class="line"><span>1 4 5 3 2  // 把 1 与最右侧的 4 比较, 满足, 不动</span></span>
<span class="line"><span>1 3 4 5 2  // 这时就以 1 为中间点, 原先的数分成了两部分, 只是 1 正好是最小的值, 所以这里就遇到了最差的情况, 有一部分为0</span></span>
<span class="line"><span>1 3 4 5 2  // 在这里就属于开始下一轮了, 比较 3, 4, 5, 2</span></span>
<span class="line"><span>1 2 4 5 3  // 3 与 2 比较, 不满足, 交换</span></span>
<span class="line"><span>1 2 3 5 4  // 3 与 4 比较, 不满足, 交换</span></span>
<span class="line"><span>1 2 3 5 4  // 这里就以为 3 标, 分成了 2 与 5, 4 两部分, 然后同样的方式去排序 5, 4 这一部分, 2 这一部分就不用动了, 只有一个数嘛</span></span>
<span class="line"><span>....</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="选择排序" tabindex="-1"><a class="header-anchor" href="#选择排序"><span>选择排序</span></a></h3><p>这个和插入排序有点类, 不过它是每次在未排序的数中选一个最小(或最大的), 然后添加到已排序的后面就可以了</p><p>插入排序是从未排序的数中随机选一个, 然后插入到前面已排序的数中, 它的排序比较过程是在已排序中进行的<br> 而选择的排序是在未排序的数中选出最小(或最大), 直接排在已排序后面就可以了, 它的比较过程是在未排序数中</p><p>例子, 我们要从小到大. 过程如下:</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-"><span class="line"><span>1 4 5 3 2  // 先选出最小的1, 并把它放在第1位</span></span>
<span class="line"><span>1 2 4 5 3  // 在第二位往后, 选出 2, 并把它放在第 2 位</span></span>
<span class="line"><span>1 2 3 4 5  // 在第三位往后中选出最小的 3 , 并把它放在已排好序队列后, 也就是第 3 位</span></span>
<span class="line"><span>...</span></span>
<span class="line"><span>1 2 3 4 5  // 同理可以把 4, 5 排好, 得到最终的已排好的队列</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="归并排序" tabindex="-1"><a class="header-anchor" href="#归并排序"><span>归并排序</span></a></h3><p>这个方法, 我很少用, 它也有点像分而治之, 它会把整体数组从中间分成两部分, 然后递归在上一步的部分再分成两部分, 很明显, 这样操作之后, 整个数组就被分成了一颗树, 然后从树支开始, 相邻两个兄弟结点比较排序, 完成后, 就往上回溯为父结点, 这样回溯到最终结点, 整个数组的排序也就完成了.</p><p>先把 1 4 5 3 2 做成这样一棵树</p><pre><code>  1 4 5    |    3   2
    |             |
|───────|     |───────|
|       |     |       |
</code></pre><p>1 4 | 5 | 3 | 2<br> |<br> |───────|<br> 1 4 5 3 2</p><p>再把树回溯</p><p>1 4 5 3 2<br> |───────|<br> |<br> 1 4 | 5 | 3 | 2<br> |───────|<br> |<br> 1 4 5 | 2 3<br> |───────|<br> |<br> 1 2 3 4 5</p><p>所以这个算法, 其实是要先构建树, 然后再回溯, 回溯(收缩)时的比较, 只需要两个兄弟结点各自前面的两个数, 因为结点本身是已经排好序的了.</p><h3 id="基数排序" tabindex="-1"><a class="header-anchor" href="#基数排序"><span>基数排序</span></a></h3><p>基数排序这个挺有意思的, 总的来说, 就是先以个位数来排序, 然后再以十位数来排序, 依次往大的位数上来排.<br> 在排序的时候, 其实也很有意思, 不是用的我们传统上的两两比较, 而是分组, 按当前比较位数分对应的组就可以了.</p><p>例子, 我们要从小到大. 过程如下:</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-"><span class="line"><span>32 42 95 89 57 24</span></span>
<span class="line"><span>32 42 24 95 57 89  // 按个位排序后</span></span>
<span class="line"><span>24 32 42 57 89 95  // 按十位排序后</span></span>
<span class="line"><span>// 这里就完成了排序, 这里面最大的数就是两位, 所以只需要排两轮.</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>其实从上面的例子过程中可以看出来, 基数排序把以前的整数作比较, 变成了只比较对应位数上的值, 或者可以换个说法, 放十个桶(0 - 9) , 当比较对应位时, 就按位把数放进桶中, 放完再依次合到原数组中, 再按下一位再放进桶中, 所以其实数位的比较就放在了分组这一部分了.</p><h3 id="希尔排序" tabindex="-1"><a class="header-anchor" href="#希尔排序"><span>希尔排序</span></a></h3><p>要理解希尔排序, 其实就要了解到简单的冒泡排序, 在最差情况下(最小的数在最大的数的位置上), 那最小的数要回到自己的位置要跟所有的数依次比较, 每比一次, 前进一步. 希尔排序就想解决这个问题, 它是这样做的: 把所有的数按坐标以 step 为步进分组( step 第一次一般为数组 length/2 ), 然后就会有 length/2 个小组, 然后在每个小组里各自排序, 然后将 step 除 2, 这样就有 length/4 个小组. 在这些小组内再排序. 依次把 step 除2 , 直到 step 变为1, 整个数组是一个小组，排序也就完成了。</p><p>例子, 我们要从小到大. 过程如下:</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-"><span class="line"><span>32 42 95 89 57 24</span></span>
<span class="line"><span>32 42 24 89 57 95  // step: 3 =&gt; 32, 89 | 42, 57 | 95, 24 为组</span></span>
<span class="line"><span>24 32 42 57 89 95  // step: 1 =&gt; 整个组为一个小组</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>希尔排序就是把大组分成小组来排, 然后再慢慢按step分成大组来排.</p><h3 id="堆排序" tabindex="-1"><a class="header-anchor" href="#堆排序"><span>堆排序</span></a></h3><p>堆排序这个一般用二叉树, 首先用当前的数组构建一个树, 然后从第一个非叶结点开始, 保证当前结点大于自己的两个子结点. 如果不满足, 就把大于当前结点的子结点与当前结点的数交换, 再依次往上走. 那么这样之后, 明显我们可以知道, 根结点肯定是最大的数, 然后把这个最大的数放在排好的序中最大的位置上. 再把树中最后位置的数放到根结点中. 再重复做刚才的事。从这个流程可知, 其实就是在用树来选最大的值, 这个就和选择排序有点像了, 只是我们在做选择排序的选择时， 是一个一个比较去选, 这里是通过树来选.</p><hr><p>转自: <a href="http://www.hugohuang.xyz/" target="_blank" rel="noopener noreferrer">HH</a></p>`,44)]))}const c=n(p,[["render",l]]),h=JSON.parse('{"path":"/posts/2021-10-20-sort-method.html","title":"排序算法","lang":"zh-CN","frontmatter":{"title":"排序算法","date":"2021-10-20T00:00:00.000Z","author":"hugo","tag":["design mode"],"description":"前言 早上刷新闻时看到了排序算法, 今天就来说说我所知道用到的一些排序算法. 排序算法 冒泡 最经典的排序算法了, 它最思想就是相邻的两个数对比, 并保证, 他们的顺序是按目标顺序排列的. 例子, 我们要从小到大. 过程如下: 说明: 冒泡一直在做的事就是让相邻的两个数满足目标的大小关系(左大于右, 还是右大于左). 其实在每一轮的过程中, 就会有一个...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"排序算法\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2021-10-20T00:00:00.000Z\\",\\"dateModified\\":\\"2025-06-21T17:07:42.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"hugo\\"}]}"],["meta",{"property":"og:url","content":"https://mister-hope.github.io/Blog/posts/2021-10-20-sort-method.html"}],["meta",{"property":"og:site_name","content":"HH"}],["meta",{"property":"og:title","content":"排序算法"}],["meta",{"property":"og:description","content":"前言 早上刷新闻时看到了排序算法, 今天就来说说我所知道用到的一些排序算法. 排序算法 冒泡 最经典的排序算法了, 它最思想就是相邻的两个数对比, 并保证, 他们的顺序是按目标顺序排列的. 例子, 我们要从小到大. 过程如下: 说明: 冒泡一直在做的事就是让相邻的两个数满足目标的大小关系(左大于右, 还是右大于左). 其实在每一轮的过程中, 就会有一个..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-06-21T17:07:42.000Z"}],["meta",{"property":"article:author","content":"hugo"}],["meta",{"property":"article:tag","content":"design mode"}],["meta",{"property":"article:published_time","content":"2021-10-20T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-06-21T17:07:42.000Z"}]]},"git":{"createdTime":1750525662000,"updatedTime":1750525662000,"contributors":[{"name":"hugo","username":"hugo","email":"hugohuang1111@gmail.com","commits":1,"url":"https://github.com/hugo"}]},"readingTime":{"minutes":7.97,"words":2392},"filePathRelative":"posts/2021-10-20-sort-method.md","excerpt":"<h2>前言</h2>\\n<p>早上刷新闻时看到了排序算法, 今天就来说说我所知道用到的一些排序算法.</p>\\n<h2>排序算法</h2>\\n<h3>冒泡</h3>\\n<p>最经典的排序算法了, 它最思想就是相邻的两个数对比, 并保证, 他们的顺序是按目标顺序排列的.</p>\\n<p>例子, 我们要从小到大. 过程如下:</p>\\n<div class=\\"language- line-numbers-mode\\" data-highlighter=\\"shiki\\" data-ext=\\"\\" style=\\"--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34\\"><pre class=\\"shiki shiki-themes one-light one-dark-pro vp-code\\"><code class=\\"language-\\"><span class=\\"line\\"><span>1 4 5 3 2  // 原始队列</span></span>\\n<span class=\\"line\\"><span>1 4 5 3 2  // 1 与 4 不同交换</span></span>\\n<span class=\\"line\\"><span>1 4 5 3 2  // 4 与 5 也不同交换</span></span>\\n<span class=\\"line\\"><span>1 4 3 5 2  // 5 与 3 需要交换</span></span>\\n<span class=\\"line\\"><span>1 4 3 2 5  // 5 与 2 需要交换</span></span>\\n<span class=\\"line\\"><span>// 到这里一轮结束, 同时可以注意到最时最大的 5 已经到最后的位置了, 下一轮在前 4 个数中再重复上面的步骤即可</span></span>\\n<span class=\\"line\\"><span></span></span>\\n<span class=\\"line\\"><span>....</span></span></code></pre>\\n<div class=\\"line-numbers\\" aria-hidden=\\"true\\" style=\\"counter-reset:line-number 0\\"><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div></div></div>","autoDesc":true}');export{c as comp,h as data};
