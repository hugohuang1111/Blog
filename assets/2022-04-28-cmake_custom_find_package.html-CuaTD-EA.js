import{_ as a}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as e,d as s,o as n}from"./app-CQ2TP62M.js";const t={};function p(r,i){return n(),e("div",null,i[0]||(i[0]=[s(`<h2 id="背景" tabindex="-1"><a class="header-anchor" href="#背景"><span>背景</span></a></h2><p>最近遇到一个需求,需要自定义 find_package 的实现. 特此记录一下. 在这个文章里, 我用 ZLIB 来作为演示的例子.</p><p>比如: 我们现在有这样一种情况, 有一个工程 P , 它依赖了库 ZLIB, LibA, LibB, 同时 LibA, LibB又依赖于 ZLIB.</p><pre><code>           Project
             │
</code></pre><p>┌───────────────┼───────────────┐<br> │ ▼ ▼<br> │ LibA LibB<br> │ │ │<br> ▼ ▼ ▼<br> ZLIB ZLIB ZLIB</p><p>这里我们可以把 ZLIB 安装在系统库中, 这样我们在 Project/LibA/LibB 中直接使用 find_package(ZLIB) 就可以找到 ZLIB , 但是, 如果我们想要把 ZLIB 放在 Project 工程中或一个自定义的目录下, 但是又不想改动 LibA, LibB 中的查找的方式, 那么我们就需要用到自定义的 find_package 了.</p><h2 id="find-package-的库查找" tabindex="-1"><a class="header-anchor" href="#find-package-的库查找"><span>find_package 的库查找</span></a></h2><p>要想自定义 find_package , 我们首先要了解 cmake 中 find_package 的运行方式. cmake 中的 find_package 其实最终会调用 cmake 中的一个 FindXXX.cmake 的脚本. 如果调用用了 find_package(ABC) , 那么最终就会在 cmake 中找到 FindABC.cmake 并运行, 最终也是 FindABC.cmake 来实现 ABC 这个库的查找.</p><p>所以从这个查找逻辑基本就明白了, cmake 内置的 FindXXX.cmake 只会是最常用的一些库, 而且也只能找到固定的位置. 所以我们在使用 find_package 中, 经常会遇到失败的时候, 就是这个原因.</p><p>所以我们在很多时候都会自定义 FindXXX.camke 来自己实现库的头文件/库文件的查找. 比如这里我们就会自己实现一个 FindZLIB.cmake 来查找自己的 zlib 库.</p><h2 id="findxxx-camke-的实现" tabindex="-1"><a class="header-anchor" href="#findxxx-camke-的实现"><span>FindXXX.camke 的实现</span></a></h2><p>所有的 FindXXX.cmake 脚本, 其实最终就是在给 XXX_INCLUDE_DIR, XXX_LIBRARY, XXX_INCLUDE_DIRS, XXX_LIBRARIES, XXX_FOUND 赋值.</p><p>这里给出一个极简的 FindZLIB.cmake 的例子</p><div class="language-cmake line-numbers-mode" data-highlighter="shiki" data-ext="cmake" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-cmake"><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">set</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(ZLIB_INCLUDE_DIR </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">path</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">/to/zlib/include)</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">set</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(ZLIB_LIBRARY </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">path</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">/to/zlib/lib)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">set</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(ZLIB_INCLUDE_DIRS </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">\${ZLIB_INCLUDE_DIR}</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">set</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(ZLIB_LIBRARIES </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">\${ZLIB_LIBRARY}</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">set</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(ZLIB_FOUND </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">TRUE</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="添加脚本路径" tabindex="-1"><a class="header-anchor" href="#添加脚本路径"><span>添加脚本路径</span></a></h2><p>FindXXX.cmake 的脚本完成了, 我们还要让 cmake 能找到它, 当然可以把 FindXXX.cmake 放到 cmake 系统中(&lt;CMAKE_ROOT&gt;/share/cmake/Mdodules), 但是我们要是想放到自己的目录中, 比如工程目录, 就可以用以下方法</p><p>比如: 我们把自己的 FindZLIB.cmake 放在当前 CMakeList.txt 所在目录的 cmake 目录中,</p><div class="language-cmake line-numbers-mode" data-highlighter="shiki" data-ext="cmake" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-cmake"><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">list</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(APPEND </span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">CMAKE_MODULE_PATH</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot;\${CMAKE_CURRENT_SOURCE_DIR}/cmake&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><hr><p>转自: <a href="http://www.hugohuang.xyz/" target="_blank" rel="noopener noreferrer">HH</a></p>`,20)]))}const k=a(t,[["render",p]]),c=JSON.parse('{"path":"/posts/2022-04-28-cmake_custom_find_package.html","title":"CMake 自定义库查找","lang":"zh-CN","frontmatter":{"title":"CMake 自定义库查找","date":"2022-04-27T00:00:00.000Z","author":"hugo","tag":["cmake"],"description":"背景 最近遇到一个需求,需要自定义 find_package 的实现. 特此记录一下. 在这个文章里, 我用 ZLIB 来作为演示的例子. 比如: 我们现在有这样一种情况, 有一个工程 P , 它依赖了库 ZLIB, LibA, LibB, 同时 LibA, LibB又依赖于 ZLIB. ┌───────────────┼───────────────...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"CMake 自定义库查找\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2022-04-27T00:00:00.000Z\\",\\"dateModified\\":\\"2025-06-21T17:07:42.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"hugo\\"}]}"],["meta",{"property":"og:url","content":"https://mister-hope.github.io/Blog/posts/2022-04-28-cmake_custom_find_package.html"}],["meta",{"property":"og:site_name","content":"HH"}],["meta",{"property":"og:title","content":"CMake 自定义库查找"}],["meta",{"property":"og:description","content":"背景 最近遇到一个需求,需要自定义 find_package 的实现. 特此记录一下. 在这个文章里, 我用 ZLIB 来作为演示的例子. 比如: 我们现在有这样一种情况, 有一个工程 P , 它依赖了库 ZLIB, LibA, LibB, 同时 LibA, LibB又依赖于 ZLIB. ┌───────────────┼───────────────..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-06-21T17:07:42.000Z"}],["meta",{"property":"article:author","content":"hugo"}],["meta",{"property":"article:tag","content":"cmake"}],["meta",{"property":"article:published_time","content":"2022-04-27T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-06-21T17:07:42.000Z"}]]},"git":{"createdTime":1750525662000,"updatedTime":1750525662000,"contributors":[{"name":"hugo","username":"hugo","email":"hugohuang1111@gmail.com","commits":1,"url":"https://github.com/hugo"}]},"readingTime":{"minutes":1.88,"words":563},"filePathRelative":"posts/2022-04-28-cmake_custom_find_package.md","excerpt":"<h2>背景</h2>\\n<p>最近遇到一个需求,需要自定义 find_package 的实现. 特此记录一下. 在这个文章里, 我用 ZLIB 来作为演示的例子.</p>\\n<p>比如: 我们现在有这样一种情况, 有一个工程 P , 它依赖了库 ZLIB, LibA, LibB, 同时 LibA, LibB又依赖于 ZLIB.</p>\\n<pre><code>           Project\\n             │\\n</code></pre>\\n<p>┌───────────────┼───────────────┐<br>\\n│               ▼               ▼<br>\\n│             LibA            LibB<br>\\n│               │               │<br>\\n▼               ▼               ▼<br>\\nZLIB            ZLIB           ZLIB</p>","autoDesc":true}');export{k as comp,c as data};
