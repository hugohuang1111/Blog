import{_ as t}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,d as o,o as s}from"./app-CQ2TP62M.js";const i={};function n(r,e){return s(),a("div",null,e[0]||(e[0]=[o(`<h2 id="前言" tabindex="-1"><a class="header-anchor" href="#前言"><span>前言</span></a></h2><p>最近在帮朋友找一个工单系统, 在 Docker 的部署中遇到了在容器(Container)中要访问主机(Host)中的 mysql 的问题.<br> 而且因为我自己开发用的是 Mac , 生产环境用的是 Ubuntu . 而恰恰在这两个环境中, Docker 的容器(Container)去访问主机(Host)还不一样.<br> 遇到了很多坑, 这里特地记录一下.</p><h2 id="目标" tabindex="-1"><a class="header-anchor" href="#目标"><span>目标</span></a></h2><p>我在环境是在 Docker 中运行我的服务程序, 然后在容器中的服务程序所依赖的 mysql 是放在外部的主机上的. 那么我就需要在容器中访问主机.</p><h2 id="配置方法" tabindex="-1"><a class="header-anchor" href="#配置方法"><span>配置方法</span></a></h2><h3 id="mac" tabindex="-1"><a class="header-anchor" href="#mac"><span>Mac</span></a></h3><p>在 Mac 中, 容器中用 <code>host.docker.internal</code> 代替以前的 <code>127.0.0.1</code> 就可以了.</p><h3 id="ubuntu" tabindex="-1"><a class="header-anchor" href="#ubuntu"><span>Ubuntu</span></a></h3><p>在 Ubuntu 中, 有一种简单的, 在 <code>docker run xxx</code> 里加上 <code>--network host</code> 参数, 就可以在容器(container)里直接访问通过 <code>127.0.0.1</code> 访问到主机(Host)上的 mysql 了. 但是 <code>--network host</code> 与 <code>-p</code> 是冲突的, 而我又需要用 <code>-p</code> , 所以我换了一种方式:</p><ul><li>修改 <code>/etc/mysql/my.cnf</code> , 添加以下配置:</li></ul><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-"><span class="line"><span>[mysqld]</span></span>
<span class="line"><span>bind-address=0.0.0.0</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>不加这个配置, mysql 是监听的 <code>127.0.0.1</code> , 只能本地访问 mysql .<br> 改成 <code>0.0.0.0</code> , 这样就可以远程访问了.</p><ul><li>将 mysql 中的用户名限定到 ip . 在 mysql 中运行如下</li></ul><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-"><span class="line"><span>RENAME USER ferry@localhost TO ferry@172.18.0.2;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>以前的 ferry 这个帐号只能从本地 localhost 访问, 改成可以从 <code>172.18.0.2</code> 这个 ip (这个IP就是 docker 容器的的IP)来访问.</p><ul><li>在容器 Container 中通过 <code>172.18.0.1</code> 访问主机(Host) 上的 mysql .</li></ul><p>这里的 <code>172.18.0.1</code> 就是容器的 gateway . 这里给出一个查看 gateway 的方法. 在主机(Host)上运行如下命令就可以看到</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-"><span class="line"><span>ifconfig docker0</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>至此, 再以正常的路径布署你的 Docker 程序就可以了.</p><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h2><p>对于 Ubuntu/Linux 上访问主机(Host) 上的 mysql 总结如下:</p><ul><li>让 mysql 监听 <code>0.0.0.0</code> , 这样所有 ip 都可以访问</li><li>查 Docker 中 Container 的 gateway , 这样才能知道在容器中应该访问哪个 ip ,才能访问到 mysql</li><li>mysql 中的帐号需要绑定到容器上的 ip, 这样才有访问权限.</li></ul><hr><p>转自: <a href="http://www.hugohuang.xyz/" target="_blank" rel="noopener noreferrer">HH</a></p>`,24)]))}const d=t(i,[["render",n]]),h=JSON.parse('{"path":"/posts/2021-12-13-docker_access_host.html","title":"在 Docker 的容器(Container)里访问主机(Host)上 mysql","lang":"zh-CN","frontmatter":{"title":"在 Docker 的容器(Container)里访问主机(Host)上 mysql","date":"2021-12-13T00:00:00.000Z","author":"hugo","tag":["docker"],"description":"前言 最近在帮朋友找一个工单系统, 在 Docker 的部署中遇到了在容器(Container)中要访问主机(Host)中的 mysql 的问题. 而且因为我自己开发用的是 Mac , 生产环境用的是 Ubuntu . 而恰恰在这两个环境中, Docker 的容器(Container)去访问主机(Host)还不一样. 遇到了很多坑, 这里特地记录一下....","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"在 Docker 的容器(Container)里访问主机(Host)上 mysql\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2021-12-13T00:00:00.000Z\\",\\"dateModified\\":\\"2025-06-21T17:07:42.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"hugo\\"}]}"],["meta",{"property":"og:url","content":"https://mister-hope.github.io/Blog/posts/2021-12-13-docker_access_host.html"}],["meta",{"property":"og:site_name","content":"HH"}],["meta",{"property":"og:title","content":"在 Docker 的容器(Container)里访问主机(Host)上 mysql"}],["meta",{"property":"og:description","content":"前言 最近在帮朋友找一个工单系统, 在 Docker 的部署中遇到了在容器(Container)中要访问主机(Host)中的 mysql 的问题. 而且因为我自己开发用的是 Mac , 生产环境用的是 Ubuntu . 而恰恰在这两个环境中, Docker 的容器(Container)去访问主机(Host)还不一样. 遇到了很多坑, 这里特地记录一下...."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-06-21T17:07:42.000Z"}],["meta",{"property":"article:author","content":"hugo"}],["meta",{"property":"article:tag","content":"docker"}],["meta",{"property":"article:published_time","content":"2021-12-13T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-06-21T17:07:42.000Z"}]]},"git":{"createdTime":1750525662000,"updatedTime":1750525662000,"contributors":[{"name":"hugo","username":"hugo","email":"hugohuang1111@gmail.com","commits":1,"url":"https://github.com/hugo"}]},"readingTime":{"minutes":1.89,"words":567},"filePathRelative":"posts/2021-12-13-docker_access_host.md","excerpt":"<h2>前言</h2>\\n<p>最近在帮朋友找一个工单系统, 在 Docker 的部署中遇到了在容器(Container)中要访问主机(Host)中的 mysql 的问题.<br>\\n而且因为我自己开发用的是 Mac , 生产环境用的是 Ubuntu . 而恰恰在这两个环境中, Docker 的容器(Container)去访问主机(Host)还不一样.<br>\\n遇到了很多坑, 这里特地记录一下.</p>\\n<h2>目标</h2>\\n<p>我在环境是在 Docker 中运行我的服务程序, 然后在容器中的服务程序所依赖的 mysql 是放在外部的主机上的. 那么我就需要在容器中访问主机.</p>\\n<h2>配置方法</h2>","autoDesc":true}');export{d as comp,h as data};
