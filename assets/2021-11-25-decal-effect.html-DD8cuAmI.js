import{_ as i}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,d as e,o as h}from"./app-CQ2TP62M.js";const t="/Blog/assets/202111/decal.gif",n={};function l(p,s){return h(),a("div",null,s[0]||(s[0]=[e('<h2 id="前言" tabindex="-1"><a class="header-anchor" href="#前言"><span>前言</span></a></h2><p>最近看到一个贴花效果, 感觉不错, 所以想自己来亲自实现一次.</p><h2 id="效果" tabindex="-1"><a class="header-anchor" href="#效果"><span>效果</span></a></h2><figure><img src="'+t+`" alt="Decal" tabindex="0" loading="lazy"><figcaption>Decal</figcaption></figure><h2 id="思路" tabindex="-1"><a class="header-anchor" href="#思路"><span>思路</span></a></h2><p>贴花的实现方式有很多, 我这里用了最常见, 也是适应性最好的一种方式.<br> 基于点击位置, 作立方体裁剪, 然后裁剪下来的mesh作平面投影, 最后就得到了在二维平面的UV值.<br> 最后用裁剪后的 mesh 生成新一个 meshrenderer , 再加上得到的 UV 值, 就可以把贴花贴到对应的模型上了.</p><h2 id="关键实现步骤" tabindex="-1"><a class="header-anchor" href="#关键实现步骤"><span>关键实现步骤</span></a></h2><h3 id="找到模型上的触摸的位置" tabindex="-1"><a class="header-anchor" href="#找到模型上的触摸的位置"><span>找到模型上的触摸的位置</span></a></h3><p>找模型的上触摸点, 最主要以下这两步, 找到从屏幕发射出去的射线, 取射线与模型的交点.</p><div class="language-typescript line-numbers-mode" data-highlighter="shiki" data-ext="typescript" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-typescript"><span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">this</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">mainCamera</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">?.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">screenPointToRay</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">point</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">x</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">point</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">y</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">this</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">_ray</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#986801;--shiki-dark:#E5C07B;"> intersectCount</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;"> geometry</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">intersect</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">rayModel</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">this</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">_ray</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">mo</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">this</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">modOpt</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="以触摸点为中心裁剪mesh" tabindex="-1"><a class="header-anchor" href="#以触摸点为中心裁剪mesh"><span>以触摸点为中心裁剪mesh</span></a></h3><p>以触摸点为中心立方体的六个面来裁剪当前的 mesh</p><div class="language-typescript line-numbers-mode" data-highlighter="shiki" data-ext="typescript" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-typescript"><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 其中一个面</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">this</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">decalVertexes</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> this</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">clipGeometrylByPlane</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">this</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">decalVertexes</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">new</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> Vec3</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">( </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> ), </span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">this</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">scale</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">x</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">/</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">2</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="将mesh投影到平面上得到uv" tabindex="-1"><a class="header-anchor" href="#将mesh投影到平面上得到uv"><span>将mesh投影到平面上得到uv</span></a></h3><p>然后以裁剪后的 mesh , 我们投影到面上, 再归一化, 就可以它投影后的值当 UV 用</p><div class="language-typescript line-numbers-mode" data-highlighter="shiki" data-ext="typescript" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-typescript"><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">decalVertex</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">uv</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> Vec2</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span></span>
<span class="line"><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">        0.5</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> +</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> ( </span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">decalVertex</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">viewPos</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">x</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> /</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> this</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">scale</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">x</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> ),</span></span>
<span class="line"><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">        0.5</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> +</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> ( </span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">decalVertex</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">viewPos</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">y</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> /</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> this</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">scale</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">y</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> )</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    );</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="用裁剪后的mesh和uv生成新的mesh" tabindex="-1"><a class="header-anchor" href="#用裁剪后的mesh和uv生成新的mesh"><span>用裁剪后的mesh和uv生成新的mesh</span></a></h3><p>最后我们用了新的 mesh, 同时也有了对应的 UV , 那么再加上我们要贴花的纹理, 就齐活了.</p><h2 id="仓库" tabindex="-1"><a class="header-anchor" href="#仓库"><span>仓库</span></a></h2><p><a href="https://github.com/hugohuang1111/fxcase/tree/master/assets/caseDecals/method2" target="_blank" rel="noopener noreferrer">https://github.com/hugohuang1111/fxcase/tree/master/assets/caseDecals/method2</a></p><hr><p>转自: <a href="http://www.hugohuang.xyz/" target="_blank" rel="noopener noreferrer">HH</a></p>`,22)]))}const d=i(n,[["render",l]]),g=JSON.parse('{"path":"/posts/2021-11-25-decal-effect.html","title":"贴花效果","lang":"zh-CN","frontmatter":{"title":"贴花效果","date":"2021-11-25T00:00:00.000Z","author":"hugo","tag":["effect"],"description":"前言 最近看到一个贴花效果, 感觉不错, 所以想自己来亲自实现一次. 效果 DecalDecal 思路 贴花的实现方式有很多, 我这里用了最常见, 也是适应性最好的一种方式. 基于点击位置, 作立方体裁剪, 然后裁剪下来的mesh作平面投影, 最后就得到了在二维平面的UV值. 最后用裁剪后的 mesh 生成新一个 meshrenderer , 再加上得...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"贴花效果\\",\\"image\\":[\\"https://mister-hope.github.io/Blog/assets/202111/decal.gif\\"],\\"datePublished\\":\\"2021-11-25T00:00:00.000Z\\",\\"dateModified\\":\\"2025-06-21T17:07:42.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"hugo\\"}]}"],["meta",{"property":"og:url","content":"https://mister-hope.github.io/Blog/posts/2021-11-25-decal-effect.html"}],["meta",{"property":"og:site_name","content":"HH"}],["meta",{"property":"og:title","content":"贴花效果"}],["meta",{"property":"og:description","content":"前言 最近看到一个贴花效果, 感觉不错, 所以想自己来亲自实现一次. 效果 DecalDecal 思路 贴花的实现方式有很多, 我这里用了最常见, 也是适应性最好的一种方式. 基于点击位置, 作立方体裁剪, 然后裁剪下来的mesh作平面投影, 最后就得到了在二维平面的UV值. 最后用裁剪后的 mesh 生成新一个 meshrenderer , 再加上得..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://mister-hope.github.io/Blog/assets/202111/decal.gif"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-06-21T17:07:42.000Z"}],["meta",{"property":"article:author","content":"hugo"}],["meta",{"property":"article:tag","content":"effect"}],["meta",{"property":"article:published_time","content":"2021-11-25T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-06-21T17:07:42.000Z"}]]},"git":{"createdTime":1750525662000,"updatedTime":1750525662000,"contributors":[{"name":"hugo","username":"hugo","email":"hugohuang1111@gmail.com","commits":1,"url":"https://github.com/hugo"}]},"readingTime":{"minutes":1.28,"words":383},"filePathRelative":"posts/2021-11-25-decal-effect.md","excerpt":"<h2>前言</h2>\\n<p>最近看到一个贴花效果, 感觉不错, 所以想自己来亲自实现一次.</p>\\n<h2>效果</h2>\\n<figure><img src=\\"/assets/202111/decal.gif\\" alt=\\"Decal\\" tabindex=\\"0\\" loading=\\"lazy\\"><figcaption>Decal</figcaption></figure>\\n<h2>思路</h2>\\n<p>贴花的实现方式有很多, 我这里用了最常见, 也是适应性最好的一种方式.<br>\\n基于点击位置, 作立方体裁剪, 然后裁剪下来的mesh作平面投影, 最后就得到了在二维平面的UV值.<br>\\n最后用裁剪后的 mesh 生成新一个 meshrenderer , 再加上得到的 UV 值, 就可以把贴花贴到对应的模型上了.</p>","autoDesc":true}');export{d as comp,g as data};
