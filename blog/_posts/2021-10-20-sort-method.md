---
title: 排序算法
date: 2021-10-20
author: hugo
tags:
    design mode
---

## 前言

早上刷新闻时看到了排序算法, 今天就来说说我所知道用到的一些排序算法.

## 排序算法

### 冒泡

最经典的排序算法了, 它最思想就是相邻的两个数对比, 并保证, 他们的顺序是按目标顺序排列的.

例子, 我们要从小到大. 过程如下:
```
1 4 5 3 2  // 原始队列
1 4 5 3 2  // 1 与 4 不同交换
1 4 5 3 2  // 4 与 5 也不同交换
1 4 3 5 2  // 5 与 3 需要交换
1 4 3 2 5  // 5 与 2 需要交换
// 到这里一轮结束, 同时可以注意到最时最大的 5 已经到最后的位置了, 下一轮在前 4 个数中再重复上面的步骤即可

....
```

说明: 冒泡一直在做的事就是让相邻的两个数满足目标的大小关系(左大于右, 还是右大于左).
其实在每一轮的过程中, 就会有一个数找到它的位置.
在数据的比较中, 要注意一个地方就是数据流动的方向, 如果是按最大的向右流动, 那么一轮之后, 这一轮最右的那个位置就不在下一轮的范围内了.
同理, 如果是最大的向左流动, 那么这一轮最左的位置, 就不在下一轮的范围内了.

### 插入排序

插入排序的基本思想是, 先预想第一个数, 已经排好了, 然后把第二个数插入到第一个数的队列中. 同理再把第三个数插入到前面两个数组成的队列中, 依次类推.

例子, 我们要从小到大. 过程如下:
```
1 4 5 3 2  // 原始队列
1 4 5 3 2  // 1 自己是一个队列
1 4 5 3 2  // 把 4 加入到 1 中, 4 与 1 比较, 满足, 不用动
1 4 5 3 2  // 把 5 与 1, 4 比较, 满足, 不用动
1 3 4 5 2  // 把 3 与 1, 4, 5 比较, 3 应该在 4 前面, 插入
1 2 3 4 5  // 把 2 与 1, 3, 4, 5 比较, 2 应该在 3 前面, 插入
```

### 快速排序

快速排序是我们接触得比较多的一种算法了, 总的思想就是先随机找一个数, 再以这个数为标, 把原来的数就可以分成两部分(大于标的数与不大于标的数), 然后再对这分出来的这两部分再做随机在其中选一个数, 再往下分, 如此下去, 当不可再分时, 排序也就完成了.

快速排序, 最主要的思想就是分而治之
快速排序, 会快, 其实最主要还是分而治之了, 这样小的那部分数就不用再和大的那部分数去比较, 好的情况下就少了一半的比较量. 当然差的情况下(每一次其中一部分的数量都是0, 这时的 标的数 就是最小,最大的时候), 其实和冒泡/插入也一样了, 基本就要和所有的数依次比较.

例子, 我们要从小到大. 过程如下:
```
1 4 5 3 2  // 以 1 为标的数, 把 1 与最右侧的 2 比较, 满足, 不动
1 4 5 3 2  // 把 1 与最右侧的 3 比较, 满足, 不动
1 4 5 3 2  // 把 1 与最右侧的 5 比较, 满足, 不动
1 4 5 3 2  // 把 1 与最右侧的 4 比较, 满足, 不动
1 3 4 5 2  // 这时就以 1 为中间点, 原先的数分成了两部分, 只是 1 正好是最小的值, 所以这里就遇到了最差的情况, 有一部分为0
1 3 4 5 2  // 在这里就属于开始下一轮了, 比较 3, 4, 5, 2
1 2 4 5 3  // 3 与 2 比较, 不满足, 交换
1 2 3 5 4  // 3 与 4 比较, 不满足, 交换
1 2 3 5 4  // 这里就以为 3 标, 分成了 2 与 5, 4 两部分, 然后同样的方式去排序 5, 4 这一部分, 2 这一部分就不用动了, 只有一个数嘛
....
```

### 选择排序

这个和插入排序有点类, 不过它是每次在未排序的数中选一个最小(或最大的), 然后添加到已排序的后面就可以了

插入排序是从未排序的数中随机选一个, 然后插入到前面已排序的数中, 它的排序比较过程是在已排序中进行的
而选择的排序是在未排序的数中选出最小(或最大), 直接排在已排序后面就可以了, 它的比较过程是在未排序数中


例子, 我们要从小到大. 过程如下:
```
1 4 5 3 2  // 先选出最小的1, 并把它放在第1位
1 2 4 5 3  // 在第二位往后, 选出 2, 并把它放在第 2 位
1 2 3 4 5  // 在第三位往后中选出最小的 3 , 并把它放在已排好序队列后, 也就是第 3 位
...
1 2 3 4 5  // 同理可以把 4, 5 排好, 得到最终的已排好的队列
```

### 归并排序

这个方法, 我很少用, 它也有点像分而治之, 它会把整体数组从中间分成两部分, 然后递归在上一步的部分再分成两部分, 很明显, 这样操作之后, 整个数组就被分成了一颗树, 然后从树支开始, 相邻两个兄弟结点比较排序, 完成后, 就往上回溯为父结点, 这样回溯到最终结点, 整个数组的排序也就完成了.

先把 1 4 5 3 2 做成这样一棵树

      1 4 5    |    3   2
        |             |
    |───────|     |───────|
    |       |     |       |
  1   4 |   5  |  3   |   2
    |
 |───────|
 1       4  5     3       2

再把树回溯

 1       4  5     3       2
 |───────|
    |
  1   4 |   5  |  3   |   2
    |───────|
        |
    1  4   5  |   2  3
          |───────|
              |
          1 2 3 4 5

所以这个算法, 其实是要先构建树, 然后再回溯, 回溯(收缩)时的比较, 只需要两个兄弟结点各自前面的两个数, 因为结点本身是已经排好序的了.




---
转自: [HH](http://www.hugohuang.xyz/)

