---
title: 排序算法
date: 2021-10-20
author: hugo
tags:
    design mode
---

## 前言

早上刷新闻时看到了排序算法, 今天就来说说我所知道用到的一些排序算法.

## 排序算法

### 冒泡

最经典的排序算法了, 它最思想就是相邻的两个数对比, 并保证, 他们的顺序是按目标顺序排列的.

例子, 我们要从小到大. 过程如下:
```
1 4 5 3 2  // 原始队列
1 4 5 3 2  // 1 与 4 不同交换
1 4 5 3 2  // 4 与 5 也不同交换
1 4 3 5 2  // 5 与 3 需要交换
1 4 3 2 5  // 5 与 2 需要交换
// 到这里一轮结束, 同时可以注意到最时最大的 5 已经到最后的位置了, 下一轮在前 4 个数中再重复上面的步骤即可

....
```

说明: 冒泡一直在做的事就是让相邻的两个数满足目标的大小关系(左大于右, 还是右大于左).
其实在每一轮的过程中, 就会有一个数找到它的位置.
在数据的比较中, 要注意一个地方就是数据流动的方向, 如果是按最大的向右流动, 那么一轮之后, 这一轮最右的那个位置就不在下一轮的范围内了.
同理, 如果是最大的向左流动, 那么这一轮最左的位置, 就不在下一轮的范围内了.

### 插入排序

插入排序的基本思想是, 先预想第一个数, 已经排好了, 然后把第二个数插入到第一个数的队列中. 同理再把第三个数插入到前面两个数组成的队列中, 依次类推.

例子, 我们要从小到大. 过程如下:
```
1 4 5 3 2  // 原始队列
1 4 5 3 2  // 1 自己是一个队列
1 4 5 3 2  // 把 4 加入到 1 中, 4 与 1 比较, 满足, 不用动
1 4 5 3 2  // 把 5 与 1, 4 比较, 满足, 不用动
1 3 4 5 2  // 把 3 与 1, 4, 5 比较, 3 应该在 4 前面, 插入
1 2 3 4 5  // 把 2 与 1, 3, 4, 5 比较, 2 应该在 3 前面, 插入
```

### 快速排序

快速排序是我们接触得比较多的一种算法了, 总的思想就是先随机找一个数, 再以这个数为标, 把原来的数就可以分成两部分(大于标的数与不大于标的数), 然后再对这分出来的这两部分再做随机在其中选一个数, 再往下分, 如此下去, 当不可再分时, 排序也就完成了.

快速排序, 最主要的思想就是分而治之
快速排序, 会快, 其实最主要还是分而治之了, 这样小的那部分数就不用再和大的那部分数去比较, 好的情况下就少了一半的比较量. 当然差的情况下(每一次其中一部分的数量都是0, 这时的 标的数 就是最小,最大的时候), 其实和冒泡/插入也一样了, 基本就要和所有的数依次比较.

例子, 我们要从小到大. 过程如下:
```
1 4 5 3 2  // 以 1 为标的数, 把 1 与最右侧的 2 比较, 满足, 不动
1 4 5 3 2  // 把 1 与最右侧的 3 比较, 满足, 不动
1 4 5 3 2  // 把 1 与最右侧的 5 比较, 满足, 不动
1 4 5 3 2  // 把 1 与最右侧的 4 比较, 满足, 不动
1 3 4 5 2  // 这时就以 1 为中间点, 原先的数分成了两部分, 只是 1 正好是最小的值, 所以这里就遇到了最差的情况, 有一部分为0
1 3 4 5 2  // 在这里就属于开始下一轮了, 比较 3, 4, 5, 2
1 2 4 5 3  // 3 与 2 比较, 不满足, 交换
1 2 3 5 4  // 3 与 4 比较, 不满足, 交换
1 2 3 5 4  // 这里就以为 3 标, 分成了 2 与 5, 4 两部分, 然后同样的方式去排序 5, 4 这一部分, 2 这一部分就不用动了, 只有一个数嘛
....
```

### 选择排序

这个和插入排序有点类, 不过它是每次在未排序的数中选一个最小(或最大的), 然后添加到已排序的后面就可以了

插入排序是从未排序的数中随机选一个, 然后插入到前面已排序的数中, 它的排序比较过程是在已排序中进行的
而选择的排序是在未排序的数中选出最小(或最大), 直接排在已排序后面就可以了, 它的比较过程是在未排序数中


例子, 我们要从小到大. 过程如下:
```
1 4 5 3 2  // 先选出最小的1, 并把它放在第1位
1 2 4 5 3  // 在第二位往后, 选出 2, 并把它放在第 2 位
1 2 3 4 5  // 在第三位往后中选出最小的 3 , 并把它放在已排好序队列后, 也就是第 3 位
...
1 2 3 4 5  // 同理可以把 4, 5 排好, 得到最终的已排好的队列
```

### 归并排序

这个方法, 我很少用, 它也有点像分而治之, 它会把整体数组从中间分成两部分, 然后递归在上一步的部分再分成两部分, 很明显, 这样操作之后, 整个数组就被分成了一颗树, 然后从树支开始, 相邻两个兄弟结点比较排序, 完成后, 就往上回溯为父结点, 这样回溯到最终结点, 整个数组的排序也就完成了.

先把 1 4 5 3 2 做成这样一棵树

      1 4 5    |    3   2
        |             |
    |───────|     |───────|
    |       |     |       |
  1   4 |   5  |  3   |   2
    |
 |───────|
 1       4  5     3       2

再把树回溯

 1       4  5     3       2
 |───────|
    |
  1   4 |   5  |  3   |   2
    |───────|
        |
    1  4   5  |   2  3
          |───────|
              |
          1 2 3 4 5

所以这个算法, 其实是要先构建树, 然后再回溯, 回溯(收缩)时的比较, 只需要两个兄弟结点各自前面的两个数, 因为结点本身是已经排好序的了.


### 基数排序

基数排序这个挺有意思的, 总的来说, 就是先以个位数来排序, 然后再以十位数来排序, 依次往大的位数上来排.
在排序的时候, 其实也很有意思, 不是用的我们传统上的两两比较, 而是分组, 按当前比较位数分对应的组就可以了.


例子, 我们要从小到大. 过程如下:
```
32 42 95 89 57 24
32 42 24 95 57 89  // 按个位排序后
24 32 42 57 89 95  // 按十位排序后
// 这里就完成了排序, 这里面最大的数就是两位, 所以只需要排两轮.
```

其实从上面的例子过程中可以看出来, 基数排序把以前的整数作比较, 变成了只比较对应位数上的值, 或者可以换个说法, 放十个桶(0 - 9) , 当比较对应位时, 就按位把数放进桶中, 放完再依次合到原数组中, 再按下一位再放进桶中, 所以其实数位的比较就放在了分组这一部分了.


### 希尔排序

要理解希尔排序, 其实就要了解到简单的冒泡排序, 在最差情况下(最小的数在最大的数的位置上), 那最小的数要回到自己的位置要跟所有的数依次比较, 每比一次, 前进一步. 希尔排序就想解决这个问题, 它是这样做的: 把所有的数按坐标以 step 为步进分组( step 第一次一般为数组 length/2 ), 然后就会有 length/2 个小组, 然后在每个小组里各自排序, 然后将 step 除 2, 这样就有 length/4 个小组. 在这些小组内再排序. 依次把 step 除2 , 直到 step 变为1, 整个数组是一个小组，排序也就完成了。

例子, 我们要从小到大. 过程如下:
```
32 42 95 89 57 24
32 42 24 89 57 95  // step: 3 => 32, 89 | 42, 57 | 95, 24 为组
24 32 42 57 89 95  // step: 1 => 整个组为一个小组
```

希尔排序就是把大组分成小组来排, 然后再慢慢按step分成大组来排.

### 堆排序

堆排序这个一般用二叉树, 首先用当前的数组构建一个树, 然后从第一个非叶结点开始, 保证当前结点大于自己的两个子结点. 如果不满足, 就把大于当前结点的子结点与当前结点的数交换, 再依次往上走. 那么这样之后, 明显我们可以知道, 根结点肯定是最大的数, 然后把这个最大的数放在排好的序中最大的位置上. 再把树中最后位置的数放到根结点中. 再重复做刚才的事。从这个流程可知, 其实就是在用树来选最大的值, 这个就和选择排序有点像了, 只是我们在做选择排序的选择时， 是一个一个比较去选, 这里是通过树来选.




---
转自: [HH](http://www.hugohuang.xyz/)

